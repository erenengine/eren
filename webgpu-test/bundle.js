(()=>{"use strict";const e={code:"struct VertexOutput {\n    @builtin(position) clip_position: vec4<f32>,\n};\n\n@vertex\nfn vs_main(\n    @builtin(vertex_index) in_vertex_index: u32,\n) -> VertexOutput {\n    var out: VertexOutput;\n    let x = f32(1 - i32(in_vertex_index)) * 0.5;\n    let y = f32(i32(in_vertex_index & 1u) * 2 - 1) * 0.5;\n    out.clip_position = vec4<f32>(x, y, 0.0, 1.0);\n    return out;\n}\n\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n    return vec4<f32>(0.3, 0.2, 0.1, 1.0);\n}",label:"test.wgsl"};!async function(){if(!navigator.gpu)throw alert("WebGPU is not available."),new Error("WebGPU support is not available");const t=await navigator.gpu.requestAdapter();if(!t)return void alert("Failed to request Adapter.");let n=await t.requestDevice();if(!n)return void alert("Failed to request Device.");const r=document.getElementById("canvas"),i=r.getContext("webgpu");if(!i)return void alert("Failed to get WebGPU context.");const a={device:n,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT,alphaMode:"opaque"};i.configure(a);const o=n.createShaderModule(e),u={layout:n.createPipelineLayout({bindGroupLayouts:[]}),vertex:{module:o,entryPoint:"vs_main",buffers:[]},fragment:{module:o,entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list",frontFace:"ccw",cullMode:"back"}},s=n.createRenderPipeline(u),l={colorAttachments:[{view:i.getCurrentTexture().createView(),clearValue:{r:1,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},c=n.createCommandEncoder(),d=c.beginRenderPass(l);d.setViewport(0,0,r.width,r.height,0,1),d.setPipeline(s),d.draw(3,1),d.end(),n.queue.submit([c.finish()])}()})();